# read csv file
df_filtered <- read.csv('data/google_data_filtered.csv')
# read csv file
df_filtered <- read.csv('data/google_data_filtered.csv')
df_levels_combined <- read.csv('data/google_data_levels_combined.csv')
# Count occurrences of each value in the 'level' column
table(df_levels_combined$level)
# Count values and convert to data frame
value_counts <- as.data.frame(table(df_level_combined$level))
# Count values and convert to data frame
value_counts <- as.data.frame(table(df_levels_combined$level))
# Rename columns for clarity
colnames(value_counts) <- c("Level", "Count")
# Print the result
print(value_counts)
# Load necessary libraries
library(ggplot2)
library(dplyr)
install.packages("dplyr")
# Load necessary libraries
library(ggplot2)
library(dplyr)
# Example data
df_h1b <- df_levels_combined
# Calculate the sum of downloads for each level
total_downloads_h1b <- df_h1b %>%
group_by(level) %>%
summarise(num_downloads = sum(num_downloads))
# Make a bar chart
ggplot(total_downloads_h1b, aes(x = level, y = num_downloads, fill = level)) +
geom_bar(stat = "identity", position = "dodge") +
scale_fill_viridis_d() +  # Viridis color palette
labs(
title = "Total Number of Downloads by Level",
x = "Level",
y = "Total Number of Downloads"
) +
theme_minimal() +
theme(legend.position = "none")
# Example data
df_h1b <- df_levels_combined
# Calculate the sum of downloads for each level
total_downloads_h1b <- df_h1b %>%
dplyr::group_by(level) %>%
dplyr::summarise(num_downloads = sum(num_downloads))
# Make a bar chart
ggplot2::ggplot(total_downloads_h1b, ggplot2::aes(x = level, y = num_downloads, fill = level)) +
ggplot2::geom_bar(stat = "identity", position = "dodge") +
ggplot2::scale_fill_viridis_d() +  # Viridis color palette
ggplot2::labs(
title = "Total Number of Downloads by Level",
x = "Level",
y = "Total Number of Downloads"
) +
ggplot2::theme_minimal() +
ggplot2::theme(legend.position = "none")
# read csv file
df_filtered <- read.csv('data/google_data_filtered.csv')
df_level_combined <- read.csv('data/google_data_levels_combined.csv')
# Count values and convert to data frame
value_counts <- as.data.frame(table(df_level_combined$level))
# Rename columns for clarity
colnames(value_counts) <- c("Level", "Count")
# Print the result
print(value_counts)
# Copy the dataframe
df_h1a <- df_level_combined
# If level is 0 or 1, then new column 'category' is 'Free all feature apps'
df_h1a$category <- ifelse(df_h1a$level %in% c('0', '1'), 'Free all feature apps', 'Free/Paid not all feature apps')
# Calculate the sum of downloads for each category
total_downloads_h1a <- aggregate(num_downloads ~ category, data = df_h1a, sum)
# Create a bar chart
ggplot(data = total_downloads_h1a, aes(x = category, y = num_downloads, fill = category)) +
geom_bar(stat = "identity", position = position_dodge()) +
scale_fill_viridis_d() +  # Using the viridis color palette
labs(title = "Total Number of Downloads by Category",
x = "Category",
y = "Total Number of Downloads") +
theme_minimal() +
theme(legend.position = "none")  # Removing legend since hue was used for color
# Create a bar chart using ggplot2
ggplot2::ggplot(total_downloads_h1a, ggplot2::aes(x = category, y = num_downloads, fill = category)) +
ggplot2::geom_bar(stat = "identity", position = ggplot2::position_dodge()) +
ggplot2::scale_fill_viridis_d() +  # Use viridis color palette for consistency with Python version
ggplot2::labs(title = "Total Number of Downloads by Category",
x = "Category",
y = "Total Number of Downloads") +
ggplot2::theme_minimal() +
ggplot2::theme(legend.position = "none")  # Remove the legend to avoid redundancy
# Get the list of all loaded non-base packages
loaded_packages <- setdiff(loadedNamespaces(), c("base", "stats", "graphics", "grDevices", "utils", "datasets", "methods", "tools"))
# Unload each loaded non-base package
for (pkg in loaded_packages) {
try(detach(paste("package:", pkg, sep = ""), character.only = TRUE, unload = TRUE), silent = TRUE)
}
# Create a bar chart using ggplot2
ggplot2::ggplot(total_downloads_h1a, ggplot2::aes(x = category, y = num_downloads, fill = category)) +
ggplot2::geom_bar(stat = "identity", position = ggplot2::position_dodge()) +
ggplot2::scale_fill_viridis_d() +  # Use viridis color palette for consistency with Python version
ggplot2::labs(title = "Total Number of Downloads by Category",
x = "Category",
y = "Total Number of Downloads") +
ggplot2::theme_minimal() +
ggplot2::theme(legend.position = "none")  # Remove the legend to avoid redundancy
# Copy the dataframe
df_h1a <- df_level_combined
# If level is 0 or 1, then new column 'category' is 'Free all feature apps'
df_h1a$category <- ifelse(df_h1a$level %in% c('0', '1'), 'Free all feature apps', 'Free/Paid not all feature apps')
# Calculate the sum of downloads for each category
total_downloads_h1a <- aggregate(num_downloads ~ category, data = df_h1a, sum)
# Create a bar chart using ggplot2
ggplot2::ggplot(total_downloads_h1a, ggplot2::aes(x = category, y = num_downloads, fill = category)) +
ggplot2::geom_bar(stat = "identity", position = ggplot2::position_dodge()) +
ggplot2::scale_fill_viridis_d() +  # Use viridis color palette for consistency with Python version
ggplot2::labs(title = "Total Number of Downloads by Category",
x = "Category",
y = "Total Number of Downloads") +
ggplot2::theme_minimal() +
ggplot2::theme(legend.position = "none")  # Remove the legend to avoid redundancy
reticulate::repl_python()
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
df_level_combined = pd.read_csv('./data/google_data_levels_combined.csv', dtype={7: 'string'})
pip install pandas
quit
quit
library(reticulate)
py_install("pandas")
library(reticulate)
py_install("matplotlib")
reticulate::repl_python()
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
df_level_combined = pd.read_csv('./data/google_data_levels_combined.csv', dtype={7: 'string'})
quit
library(reticulate)
py_install("seaborn")
library(reticulate)
py_install("numpy")
reticulate::repl_python()
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
df_level_combined = pd.read_csv('./data/google_data_levels_combined.csv', dtype={7: 'string'})
pd.DataFrame(df_level_combined['level'].value_counts())
df_h1b = df_level_combined.copy()
# convert float to int for num_downloads
df_h1b['num_downloads'] = df_h1b['num_downloads'].astype(int)
# relevant columns
relevant_columns_h1b = ['my_app_id', 'num_downloads', 'categ_app', 'level', 'developer_name']
# filter the relevant columns
df_h1b = df_h1b[relevant_columns_h1b]
# Calculate the sum of downloads for each level
total_downloads_h1b = df_h1b.groupby('level')['num_downloads'].sum().reset_index()
# Sort the dataframe by 'num_downloads' in descending order
df_sorted = df_h1b.sort_values(by='num_downloads', ascending=False)
# Calculate the cumulative percentage of downloads
df_sorted['cumulative_percentage_downloads'] = df_sorted['num_downloads'].cumsum() / df_sorted['num_downloads'].sum() * 100
# Create a Lorenz curve-style plot
plt.figure(figsize=(10, 6))
plt.plot(range(1, len(df_sorted) + 1), df_sorted['cumulative_percentage_downloads'], label='Cumulative Downloads')
plt.plot([1, len(df_sorted)], [0, 100], linestyle='--', color='gray', label='Equality Line')
# Add labels and title
plt.title('Distribution of App Downloads (Top-Heavy Analysis)')
plt.xlabel('Apps (sorted by downloads)')
plt.ylabel('Cumulative Percentage of Downloads')
plt.legend()
plt.grid(True)
plt.show()
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
df_level_combined = pd.read_csv('./data/google_data_levels_combined.csv', dtype={7: 'string'})
df_h1b = df_level_combined.copy()
# convert float to int for num_downloads
df_h1b['num_downloads'] = df_h1b['num_downloads'].astype(int)
# relevant columns
relevant_columns_h1b = ['my_app_id', 'num_downloads', 'categ_app', 'level', 'developer_name']
# filter the relevant columns
df_h1b = df_h1b[relevant_columns_h1b]
# Calculate the sum of downloads for each level
total_downloads_h1b = df_h1b.groupby('level')['num_downloads'].sum().reset_index()
# Sort the dataframe by 'num_downloads' in descending order
df_sorted = df_h1b.sort_values(by='num_downloads', ascending=False)
# Calculate the cumulative percentage of downloads
df_sorted['cumulative_percentage_downloads'] = df_sorted['num_downloads'].cumsum() / df_sorted['num_downloads'].sum() * 100
# Create a Lorenz curve-style plot
plt.figure(figsize=(10, 6))
plt.plot(range(1, len(df_sorted) + 1), df_sorted['cumulative_percentage_downloads'], label='Cumulative Downloads')
plt.plot([1, len(df_sorted)], [0, 100], linestyle='--', color='gray', label='Equality Line')
# Add labels and title
plt.title('Distribution of App Downloads (Top-Heavy Analysis)')
plt.xlabel('Apps (sorted by downloads)')
plt.ylabel('Cumulative Percentage of Downloads')
plt.legend()
plt.grid(True)
plt.show()
quit
quarto check jupyter
reticulate::repl_python()
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
df_level_combined = pd.read_csv('./data/google_data_levels_combined.csv', dtype={7: 'string'})
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
df_level_combined = pd.read_csv('./data/google_data_levels_combined.csv', dtype={7: 'string'})
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
df_level_combined = pd.read_csv('./data/google_data_levels_combined.csv', dtype={16: 'string'})
pd.DataFrame(df_level_combined['level'].value_counts())
reticulate::repl_python()
#| echo: false
#| warning: false
#| error: false
df_h1b[df_h1b['level'] == '1']['num_downloads'].sum()
#| echo: false
#| warning: false
#| error: false
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
df_level_combined = pd.read_csv('./data/google_data_levels_combined.csv', dtype={16: 'string'})
#| echo: false
#| warning: false
#| error: false
pd.DataFrame(df_level_combined['level'].value_counts())
#| echo: false
#| warning: false
#| error: false
df_h1b = df_level_combined.copy()
# convert float to int for num_downloads
df_h1b['num_downloads'] = df_h1b['num_downloads'].astype(int)
# relevant columns
relevant_columns_h1b = ['my_app_id', 'num_downloads', 'categ_app', 'level', 'developer_name']
# filter the relevant columns
df_h1b = df_h1b[relevant_columns_h1b]
# Calculate the sum of downloads for each level
total_downloads_h1b = df_h1b.groupby('level')['num_downloads'].sum().reset_index()
# Sort the dataframe by 'num_downloads' in descending order
df_sorted = df_h1b.sort_values(by='num_downloads', ascending=False)
# Calculate the cumulative percentage of downloads
df_sorted['cumulative_percentage_downloads'] = df_sorted['num_downloads'].cumsum() / df_sorted['num_downloads'].sum() * 100
# Create a Lorenz curve-style plot
plt.figure(figsize=(10, 6))
plt.plot(range(1, len(df_sorted) + 1), df_sorted['cumulative_percentage_downloads'], label='Cumulative Downloads')
plt.plot([1, len(df_sorted)], [0, 100], linestyle='--', color='gray', label='Equality Line')
# Add labels and title
plt.title('Distribution of App Downloads (Top-Heavy Analysis)')
plt.xlabel('Apps (sorted by downloads)')
plt.ylabel('Cumulative Percentage of Downloads')
plt.legend()
plt.grid(True)
plt.show()
#| echo: false
#| warning: false
#| error: false
df_h1b[df_h1b['level'] == '1']['num_downloads'].sum()
#| echo: false
#| warning: false
#| error: false
num_downloads = df_h1b[df_h1b['level'] == '1']['num_downloads'].sum()
billions = num_downloads / 1e9
print(f"{billions:.2f} billion")
reticulate::repl_python()
#| echo: false
#| warning: false
#| error: false+
df_h1b = df_level_combined.copy()
# Calculate the sum of downloads for each level
total_downloads_h1b = df_h1b.groupby('level')['num_downloads'].sum().reset_index()
# Make a bar chart
plt.figure(figsize=(10, 6))
sns.barplot(data=total_downloads_h1b, x='level', y='num_downloads', hue='level', palette='viridis', dodge=False)
plt.title('Total Number of Downloads by Level')
plt.xlabel('Level')
plt.ylabel('Total Number of Downloads')
plt.show()
#| echo: false
#| warning: false
#| error: false
df_h1b = df_level_combined.copy()
# Calculate the sum of downloads for each level
total_downloads_h1b = df_h1b.groupby('level')['num_downloads'].sum().reset_index()
# Make a bar chart
plt.figure(figsize=(10, 6))
sns.barplot(data=total_downloads_h1b, x='level', y='num_downloads', hue='level', palette='viridis', dodge=False)
plt.title('Total Number of Downloads by Level')
plt.xlabel('Level')
plt.ylabel('Total Number of Downloads')
plt.show()
#| echo: false
#| warning: false
#| error: false
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
df_level_combined = pd.read_csv('./data/google_data_levels_combined.csv', dtype={16: 'string'})
#| echo: false
#| warning: false
#| error: false
df_h1b = df_level_combined.copy()
# Calculate the sum of downloads for each level
total_downloads_h1b = df_h1b.groupby('level')['num_downloads'].sum().reset_index()
# Make a bar chart
plt.figure(figsize=(10, 6))
sns.barplot(data=total_downloads_h1b, x='level', y='num_downloads', hue='level', palette='viridis', dodge=False)
plt.title('Total Number of Downloads by Level')
plt.xlabel('Level')
plt.ylabel('Total Number of Downloads')
plt.show()
reticulate::repl_python()
#| echo: false
#| warning: false
#| error: false
# Make a bar chart
plt.figure(figsize=(10, 6))
sns.barplot(data=df_h1b, x='level', y='num_downloads', hue='level', palette='viridis', dodge=False)
plt.title('Total Number of Downloads by Level')
plt.xlabel('Level')
plt.ylabel('Total Number of Downloads')
plt.show()
#| echo: false
#| warning: false
#| error: false
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
df_level_combined = pd.read_csv('./data/google_data_levels_combined.csv', dtype={16: 'string'})
#| echo: false
#| warning: false
#| error: false
# Make a bar chart
plt.figure(figsize=(10, 6))
sns.barplot(data=df_h1b, x='level', y='num_downloads', hue='level', palette='viridis', dodge=False)
plt.title('Total Number of Downloads by Level')
plt.xlabel('Level')
plt.ylabel('Total Number of Downloads')
plt.show()
#| echo: false
#| warning: false
#| error: false
df_h1b = df_level_combined.copy()
# Calculate the sum of downloads for each level
total_downloads_h1b = df_h1b.groupby('level')['num_downloads'].sum().reset_index()
# Make a bar chart
plt.figure(figsize=(10, 6))
sns.barplot(data=total_downloads_h1b, x='level', y='num_downloads', hue='level', palette='viridis', dodge=False)
plt.title('Total Number of Downloads by Level')
plt.xlabel('Level')
plt.ylabel('Total Number of Downloads')
plt.show()
#| echo: false
#| warning: false
#| error: false
# Make a bar chart
plt.figure(figsize=(10, 6))
sns.barplot(data=df_h1b, x='level', y='num_downloads', hue='level', palette='viridis', dodge=False)
plt.title('Average Number of Downloads by Level')
plt.xlabel('Level')
plt.ylabel('Average Number of Downloads')
plt.show()
reticulate::repl_python()
#| echo: false
#| warning: false
#| error: false
df_level_combined_h1d = df_level_combined.copy()
# relevant columns
relevant_columns_h1d = ['my_app_id', 'num_downloads', 'level', 'categ_app']
# filter the relevant columns
df_level_combined_h1d = df_level_combined_h1d[relevant_columns_h1d]
# Creating a list of categories that can be considered as part of the gaming category
gaming_categories = [
"Puzzle", "Casual", "Arcade", "Simulation", "Action", "Adventure",
"Trivia", "Racing", "Educational", "Card", "Word", "Board",
"Casino", "Role Playing", "Strategy", "Brain Games",
"Action & Adventure", "Pretend Play"
]
# Filter on games category
df_level_combined_h1d = df_level_combined_h1d[df_level_combined_h1d['categ_app'].isin(gaming_categories)]
# barplot the number of downloads for each level
plt.figure(figsize=(5, 3))
sns.barplot(data=df_level_combined_h1d, x='level', y='num_downloads')
plt.title('Average amount of Downloads for Gaming Apps by Level')
plt.xlabel('Level')
plt.ylabel('Number of Downloads')
plt.xticks(rotation=90)  # Rotate x-axis labels
plt.show()
reticulate::repl_python()
#| echo: false
#| warning: false
#| error: false
variance_rating = df_level_combined.copy()
# Assuming your dataframe is named df
columns_to_calculate = ['rating_app', 'bayesian_average']
variance_specific = variance_rating.groupby('level')[columns_to_calculate].var().reset_index()
# Melting the dataframe to long format for easier plotting
variance_melted = variance_specific.melt(id_vars='level', var_name='Attribute', value_name='Variance')
plt.figure(figsize=(12, 6))
sns.barplot(data=variance_melted, x='level', y='Variance', hue='Attribute', palette='viridis')
plt.title('Variance of Different Attributes Grouped by Level')
plt.xlabel('Level')
plt.ylabel('Variance')
plt.xticks(rotation=45)
plt.legend(title='Attribute', loc='upper right')
plt.tight_layout()
plt.show()
