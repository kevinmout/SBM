total <- length(pos)
perc_goal <- sum(pos == "Goalkeeper") / total
perc_back <- sum(pos == "Defender") / total
perc_middle <- sum(pos == "Midfielder") / total
perc_front <- sum(pos == "Forward") / total
return(c(perc_goal, perc_back, perc_middle, perc_front))
}
# Calculate position percentages of players transferred between clubs
aggr_position_percents <- data.frame()
# Unique combinations of From, CountryFrom, To, CountryTo, LeagueFrom, and LeagueTo
temp_unique_combinations <- unique(df[, c("From", "CountryFrom", "To", "CountryTo", "LeagueFrom", "LeagueTo")])
# Loop through unique combinations and calculate percentages
for (i in 1:nrow(temp_unique_combinations)) {
temp_subset_df <- df[df$From == temp_unique_combinations$From[i] &
df$CountryFrom == temp_unique_combinations$CountryFrom[i] &
df$To == temp_unique_combinations$To[i] &
df$CountryTo == temp_unique_combinations$CountryTo[i] &
df$LeagueFrom == temp_unique_combinations$LeagueFrom[i] &
df$LeagueTo == temp_unique_combinations$LeagueTo[i], ]
perc <- get_position_percents(temp_subset_df$Position)
aggr_position_percents <- rbind(aggr_position_percents, data.frame(
From = temp_unique_combinations$From[i],
CountryFrom = temp_unique_combinations$CountryFrom[i],
To = temp_unique_combinations$To[i],
CountryTo = temp_unique_combinations$CountryTo[i],
LeagueFrom = temp_unique_combinations$LeagueFrom[i],
LeagueTo = temp_unique_combinations$LeagueTo[i],
Perc_Goal = perc[1],
Perc_Back = perc[2],
Perc_Middle = perc[3],
Perc_Front = perc[4]
))
}
#Merge the data frames
df_summary <- merge(aggr_transfer_between_clubs, aggr_average_transfer_fee,
by = c("From", "CountryFrom", "LeagueFrom", "To", "LeagueTo", "CountryTo"),
all.x = TRUE)
df_summary <- merge(df_summary, aggr_average_age,
by = c("From", "CountryFrom", "LeagueFrom", "To", "LeagueTo", "CountryTo"),
all.x = TRUE)
df_summary <- merge(df_summary, aggr_total_players,
by = c("From", "CountryFrom", "LeagueFrom", "To", "LeagueTo", "CountryTo"),
all.x = TRUE)
df_summary <- merge(df_summary, aggr_most_common_nat,
by = c("From", "CountryFrom", "LeagueFrom", "To", "LeagueTo", "CountryTo"),
all.x = TRUE)
df_summary <- merge(df_summary, aggr_position_percents,
by = c("From", "CountryFrom", "LeagueFrom", "To", "LeagueTo", "CountryTo"),
all.x = TRUE)
#Calculate total spending per club
table_spending_per_club <- aggregate(Fee ~ To, data = df, FUN = sum, na.rm = TRUE)
#Convert the spending to millions and rename the columns
table_spending_per_club$Spent <- table_spending_per_club$Fee
table_spending_per_club <- table_spending_per_club[, c("To", "Spent")]
names(table_spending_per_club)[names(table_spending_per_club) == "To"] <- "Club"
#Sort in descending order by 'Spent'
table_spending_per_club <- table_spending_per_club[order(-table_spending_per_club$Spent), ]
#Display the top 10 results
print(head(table_spending_per_club, 10))
#Calculate total income per club
table_income_per_club <- aggregate(Fee ~ From, data = df, FUN = sum, na.rm = TRUE)
#Convert the income to millions
table_income_per_club$Income <- table_income_per_club$Fee
#Rename the columns and keep only relevant ones
table_income_per_club <- table_income_per_club[, c("From", "Income")]
names(table_income_per_club)[names(table_income_per_club) == "From"] <- "Club"
#Sort in descending order by 'Income'
table_income_per_club <- table_income_per_club[order(-table_income_per_club$Income), ]
#Display the top 10 results
print(head(table_income_per_club, 10))
#Perform outer join to combine spending and income data
table_net_spending <- merge(table_spending_per_club, table_income_per_club, by = "Club", all = TRUE)
#Replace NA with 0 for Spent and Income
table_net_spending$Spent[is.na(table_net_spending$Spent)] <- 0
table_net_spending$Income[is.na(table_net_spending$Income)] <- 0
#Calculate net spending
table_net_spending$Net <- table_net_spending$Income - table_net_spending$Spent
#Sort by Net in descending order
table_net_spending <- table_net_spending[order(-table_net_spending$Net), ]
#Display the top 10 results
print(head(table_net_spending, 10))
#Create a subset of only the clubs and their outgoing transfer fees
hist_club_total_fees <- stats::aggregate(Total_Fee ~ From,
data = df_summary,
FUN = sum,
na.rm = TRUE)
#View the subset with total fees per club
print(hist_club_total_fees)
#Histograms for Total Fee over summary
ggplot2::ggplot(df_summary, ggplot2::aes(x = Total_Fee)) +
ggplot2::geom_histogram(binwidth = 1e6, fill = "skyblue", color = "black", alpha = 0.7) +
ggplot2::scale_x_continuous(labels = scales::dollar_format(prefix = "€")) +
ggplot2::labs(title = "Distribution of Total Transfer Fees",
x = "Total Fee (€)",
y = "Number of Clubs") +
ggplot2::theme_minimal()
#Histogram for Average Fee of summary
ggplot2::ggplot(df_summary, ggplot2::aes(x = Average_Fee)) +
ggplot2::geom_histogram(binwidth = 1e5, fill = "salmon", color = "black", alpha = 0.7) +
ggplot2::scale_x_continuous(labels = scales::dollar_format(prefix = "€")) +
ggplot2::labs(title = "Distribution of Average Transfer Fees",
x = "Average Fee (€)",
y = "Number of Clubs") +
ggplot2::theme_minimal()
#Histogram for club_total_fees
ggplot2::ggplot(hist_club_total_fees, ggplot2::aes(x = Total_Fee)) +
ggplot2::geom_histogram(binwidth = 1e7, fill = "skyblue", color = "black") +
ggplot2::scale_x_continuous(labels = scales::comma) +
ggplot2::labs(
title = "Distribution of Total Transfer Fees per Club",
x = "Total Transfer Fees (€)",
y = "Number of Clubs"
) +
ggplot2::theme_minimal()
#Calculate percentiles for Total Fee, including the 95th percentile
total_fee_percentiles <- stats::quantile(hist_club_total_fees$Total_Fee,
probs = c(seq(0, 0.9, 0.1), 0.95, 1),
na.rm = TRUE)
print(total_fee_percentiles)
# #CREATE TOP 10% DATASET}
# #Use only the clubs in the top 10% of total transfer fees
# top_10_percent_clubs <- club_total_fees[club_total_fees$Total_Fee >= total_fee_percentiles[["90%"]], ]
#
# #Extract the club names from this top 10% subset
# top_10_clubs <- top_10_percent_clubs$From
#
# #Filter df_summary to include only rows where From is in the top 10% clubs
# top_10_transfers <- df_summary[df_summary$From %in% top_10_clubs, ]
# #CREATE TOP 5% DATASET
# #Use only the clubs in the top 5% of total transfer fees
# top_5_percent_clubs <- club_total_fees[club_total_fees$Total_Fee >= total_fee_percentiles[["95%"]], ]
#
# #Extract the club names from this top 5% subset
# top_5_clubs <- top_5_percent_clubs$From
#
# #Filter df_summary to include only rows where From is in the top 5% clubs
# top_5_transfers <- df_summary[df_summary$From %in% top_5_clubs, ]
#
# node weight = club transfer volume (income+spent)
#Perform outer join to combine spending and income data
node_club_volume <- merge(table_spending_per_club, table_income_per_club, by = "Club", all = TRUE)
#Replace NA with 0 for Spent and Income
node_club_volume$Spent[is.na(node_club_volume$Spent)] <- 0
node_club_volume$Income[is.na(node_club_volume$Income)] <- 0
#Calculate net spending
node_club_volume$Volume <- node_club_volume$Income + node_club_volume$Spent
#Drop Income and Spent columns
node_club_volume <- subset(node_club_volume, select = -c(Income, Spent))
# node attributes:
# league/country
club <- unique(c(df_summary$From, df_summary$To))
df_just_clubs <- data.frame(Club = club)
# Example of merging based on club names
# Assuming `df_clubs` has a `club_name` column that matches `clubs_df$club`
node_league_year <- merge(df_just_clubs, temp_df_clubs, by.x = "Club", by.y = "Club", all.x = TRUE)
# drop League or Country and Year
node_league_year <- subset(node_league_year, select = -c(Year))
# remove duplicates
node_league_year <- unique(node_league_year)
node_list <- data.frame(
id = node_club_volume$Club,
volume = node_club_volume$Volume,
league = node_league_year$League,
country = node_league_year$Country
)
# edge weight = total transfer fee between clubs
# edge attributes:
# average_age
# total_players
# most_common_nat
# position_percents_gk - gk,vd,md,an
edge_list <- data.frame(
from = df_summary$From,
to = df_summary$To,
weight = df_summary$Total_Fee
# attributes
# average_age = df_summary$Average_Age
# total_players = df_summary$Total_Players,
# most_common_nat = df_summary$Nationality,
# goalkeeper = df_summary$Perc_Goal,
# defender = df_summary$Perc_Back,
# midfielder = df_summary$Perc_Middle,
# attacker = df_summary$Perc_Front
)
# Convert the igraph object to a network object using snafun
igraph <- snafun::to_igraph(edge_list, bipartite = FALSE, vertices = node_list)
net <- snafun::to_network(igraph)
net
igraph <- igraph::delete.edge.attribute(igraph, "na")
set.seed(2)
snafun::plot(igraph,
vertex.size = igraph::V(net)$volume / 1e9,
edge.arrow.width = igraph::E(net)$weight / 1e9,
edge.arrow.size = 0.8,
vertex.label.cex=0.6,
layout= igraph::layout.random,
)
set.seed(2)
snafun::plot(net,
vertex.size = igraph::V(net)$volume / 1e9,
edge.arrow.width = igraph::E(net)$weight / 1e9,
edge.arrow.size = 0.8,
vertex.label.cex=0.6,
layout= igraph::layout.random,
)
# Convert the igraph object to a network object using snafun
igraph <- snafun::to_igraph(x = edge_list, bipartite = FALSE, vertices = node_list)
net <- snafun::to_network(igraph)
net
str(edge_list)
head(edge_list)
# Convert the igraph object to a network object using snafun
igraph <- snafun::to_igraph(x = edge_list, bipartite = FALSE, vertices = node_list)
net <- snafun::to_network(igraph)
net
#| label: tbl-iris
#| tbl-cap: "Iris Data"
# Load the data from the CSV file
df_level_combined <- read.csv('./data/google_data_levels_combined.csv', stringsAsFactors = FALSE)
# Create a copy of the data frame
df_h1b <- df_level_combined
# Convert 'num_downloads' to integer
df_h1b$num_downloads <- as.integer(df_h1b$num_downloads)
# Define the relevant columns
relevant_columns_h1b <- c('my_app_id', 'num_downloads', 'categ_app', 'level', 'developer_name')
# Filter the relevant columns
df_h1b <- df_h1b[, relevant_columns_h1b]
# Further filtering and processing as per the previous steps
df_h1b <- df_h1b[df_h1b$my_app_id %in% c('com.amazon.mShop.android.shopping',
'com.instagram.android',
'com.facebook.lite',
'com.netflix.mediaclient',
'com.snapchat.android',
'com.spotify.music',
'com.whatsapp',
'com.facebook.orca'), ]
df_h1b <- df_h1b[, c('my_app_id', 'num_downloads', 'categ_app', 'level')]
df_h1b$num_downloads <- df_h1b$num_downloads / 1e9
app_mapping <- c(
'com.amazon.mShop.android.shopping' = 'Amazon Shopping',
'com.instagram.android' = 'Instagram',
'com.facebook.lite' = 'Facebook Lite',
'com.netflix.mediaclient' = 'Netflix',
'com.snapchat.android' = 'Snapchat',
'com.spotify.music' = 'Spotify',
'com.whatsapp' = 'WhatsApp',
'com.facebook.orca' = 'Facebook Messenger'
)
df_h1b$app_name <- app_mapping[df_h1b$my_app_id]
df_h1b <- df_h1b[, c('app_name', 'num_downloads', 'categ_app', 'level')]
colnames(df_h1b) <- c('App Name', 'Downloads (in B)', 'Category', 'Level')
df_h1b <- df_h1b[order(-df_h1b$`Downloads (in B)`), ]
row.names(df_h1b) <- NULL
kable(head(df_h1b))
knitr::kable(head(df_h1b))
#| label: tbl-google-data
#| tbl-cap: "Top 8 Apps by Downloads (in Billions)"
#| echo: false
#| warning: false
#| error: false
# Load the data from the CSV file
df_level_combined <- read.csv('./data/google_data_levels_combined.csv', stringsAsFactors = FALSE)
# Create a copy of the data frame
df_h1b <- df_level_combined
# Convert 'num_downloads' to integer
df_h1b$num_downloads <- as.integer(df_h1b$num_downloads)
# Define the relevant columns
relevant_columns_h1b <- c('my_app_id', 'num_downloads', 'categ_app', 'level', 'developer_name')
# Filter the relevant columns
df_h1b <- df_h1b[, relevant_columns_h1b]
# Further filtering and processing as per the previous steps
df_h1b <- df_h1b[df_h1b$my_app_id %in% c('com.amazon.mShop.android.shopping',
'com.instagram.android',
'com.facebook.lite',
'com.netflix.mediaclient',
'com.snapchat.android',
'com.spotify.music',
'com.whatsapp',
'com.facebook.orca'), ]
# Select and adjust the relevant columns
df_h1b <- df_h1b[, c('my_app_id', 'num_downloads', 'categ_app', 'level')]
# Convert downloads to billions
df_h1b$num_downloads <- df_h1b$num_downloads / 1e9
# Create a mapping of app IDs to human-readable app names
app_mapping <- c(
'com.amazon.mShop.android.shopping' = 'Amazon Shopping',
'com.instagram.android' = 'Instagram',
'com.facebook.lite' = 'Facebook Lite',
'com.netflix.mediaclient' = 'Netflix',
'com.snapchat.android' = 'Snapchat',
'com.spotify.music' = 'Spotify',
'com.whatsapp' = 'WhatsApp',
'com.facebook.orca' = 'Facebook Messenger'
)
# Map app names
df_h1b$app_name <- app_mapping[df_h1b$my_app_id]
# Reorder and rename columns
df_h1b <- df_h1b[, c('app_name', 'num_downloads', 'categ_app', 'level')]
colnames(df_h1b) <- c('App Name', 'Downloads (in B)', 'Category', 'Level')
# Sort by downloads in descending order
df_h1b <- df_h1b[order(-df_h1b$`Downloads (in B)`), ]
# Reset row names
row.names(df_h1b) <- NULL
# Display the table using knitr::kable with LaTeX support for PDF
knitr::kable(
head(df_h1b),
caption = "Top 8 Apps by Downloads (in Billions)",
format = "latex",
booktabs = TRUE
)
#| label: tbl-google-data
#| tbl-cap: "Top 8 Apps by Downloads (in Billions)"
#| echo: false
#| warning: false
#| error: false
# Load the data from the CSV file
df_level_combined <- read.csv('./data/google_data_levels_combined.csv', stringsAsFactors = FALSE)
# Create a copy of the data frame
df_h1b <- df_level_combined
# Convert 'num_downloads' to integer
df_h1b$num_downloads <- as.integer(df_h1b$num_downloads)
# Define the relevant columns
relevant_columns_h1b <- c('my_app_id', 'num_downloads', 'categ_app', 'level', 'developer_name')
# Filter the relevant columns
df_h1b <- df_h1b[, relevant_columns_h1b]
# Further filtering and processing as per the previous steps
df_h1b <- df_h1b[df_h1b$my_app_id %in% c('com.amazon.mShop.android.shopping',
'com.instagram.android',
'com.facebook.lite',
'com.netflix.mediaclient',
'com.snapchat.android',
'com.spotify.music',
'com.whatsapp',
'com.facebook.orca'), ]
# Select and adjust the relevant columns
df_h1b <- df_h1b[, c('my_app_id', 'num_downloads', 'categ_app', 'level')]
# Convert downloads to billions
df_h1b$num_downloads <- df_h1b$num_downloads / 1e9
# Create a mapping of app IDs to human-readable app names
app_mapping <- c(
'com.amazon.mShop.android.shopping' = 'Amazon Shopping',
'com.instagram.android' = 'Instagram',
'com.facebook.lite' = 'Facebook Lite',
'com.netflix.mediaclient' = 'Netflix',
'com.snapchat.android' = 'Snapchat',
'com.spotify.music' = 'Spotify',
'com.whatsapp' = 'WhatsApp',
'com.facebook.orca' = 'Facebook Messenger'
)
# Map app names
df_h1b$app_name <- app_mapping[df_h1b$my_app_id]
# Reorder and rename columns
df_h1b <- df_h1b[, c('app_name', 'num_downloads', 'categ_app', 'level')]
colnames(df_h1b) <- c('App Name', 'Downloads (in B)', 'Category', 'Level')
# Sort by downloads in descending order
df_h1b <- df_h1b[order(-df_h1b$`Downloads (in B)`), ]
# Reset row names
row.names(df_h1b) <- NULL
# Display the table using knitr::kable with LaTeX support for PDF
knitr::kable(
head(df_h1b),
caption = "Top 8 Apps by Downloads (in Billions)",
format = "latex",
)
#| label: tbl-google-data
#| tbl-cap: "Top 8 Apps by Downloads (in Billions)"
#| echo: false
#| warning: false
#| error: false
# Load the data from the CSV file
df_level_combined <- read.csv('./data/google_data_levels_combined.csv', stringsAsFactors = FALSE)
# Create a copy of the data frame
df_h1b <- df_level_combined
# Convert 'num_downloads' to integer
df_h1b$num_downloads <- as.integer(df_h1b$num_downloads)
# Define the relevant columns
relevant_columns_h1b <- c('my_app_id', 'num_downloads', 'categ_app', 'level', 'developer_name')
# Filter the relevant columns
df_h1b <- df_h1b[, relevant_columns_h1b]
# Further filtering and processing as per the previous steps
df_h1b <- df_h1b[df_h1b$my_app_id %in% c('com.amazon.mShop.android.shopping',
'com.instagram.android',
'com.facebook.lite',
'com.netflix.mediaclient',
'com.snapchat.android',
'com.spotify.music',
'com.whatsapp',
'com.facebook.orca'), ]
# Select and adjust the relevant columns
df_h1b <- df_h1b[, c('my_app_id', 'num_downloads', 'categ_app', 'level')]
# Convert downloads to billions
df_h1b$num_downloads <- df_h1b$num_downloads / 1e9
# Create a mapping of app IDs to human-readable app names
app_mapping <- c(
'com.amazon.mShop.android.shopping' = 'Amazon Shopping',
'com.instagram.android' = 'Instagram',
'com.facebook.lite' = 'Facebook Lite',
'com.netflix.mediaclient' = 'Netflix',
'com.snapchat.android' = 'Snapchat',
'com.spotify.music' = 'Spotify',
'com.whatsapp' = 'WhatsApp',
'com.facebook.orca' = 'Facebook Messenger'
)
# Map app names
df_h1b$app_name <- app_mapping[df_h1b$my_app_id]
# Reorder and rename columns
df_h1b <- df_h1b[, c('app_name', 'num_downloads', 'categ_app', 'level')]
colnames(df_h1b) <- c('App Name', 'Downloads (in B)', 'Category', 'Level')
# Sort by downloads in descending order
df_h1b <- df_h1b[order(-df_h1b$`Downloads (in B)`), ]
# Reset row names
row.names(df_h1b) <- NULL
# Display the table using knitr::kable with LaTeX support for PDF
knitr::kable(
head(df_h1b),
caption = "Top 8 Apps by Downloads (in Billions)",
format = "latex",
)
#| label: tbl-google-data
#| tbl-cap: "Top 8 Apps by Downloads (in Billions)"
#| echo: false
#| warning: false
#| error: false
#| results: asis
library(knitr)
# Load the data from the CSV file
df_level_combined <- read.csv('./data/google_data_levels_combined.csv', stringsAsFactors = FALSE)
# Create a copy of the data frame
df_h1b <- df_level_combined
# Convert 'num_downloads' to integer
df_h1b$num_downloads <- as.integer(df_h1b$num_downloads)
# Define the relevant columns
relevant_columns_h1b <- c('my_app_id', 'num_downloads', 'categ_app', 'level', 'developer_name')
# Filter the relevant columns
df_h1b <- df_h1b[, relevant_columns_h1b]
# Filter specific apps
df_h1b <- df_h1b[df_h1b$my_app_id %in% c('com.amazon.mShop.android.shopping',
'com.instagram.android',
'com.facebook.lite',
'com.netflix.mediaclient',
'com.snapchat.android',
'com.spotify.music',
'com.whatsapp',
'com.facebook.orca'), ]
# Prepare the table
df_h1b$num_downloads <- df_h1b$num_downloads / 1e9
app_mapping <- c(
'com.amazon.mShop.android.shopping' = 'Amazon Shopping',
'com.instagram.android' = 'Instagram',
'com.facebook.lite' = 'Facebook Lite',
'com.netflix.mediaclient' = 'Netflix',
'com.snapchat.android' = 'Snapchat',
'com.spotify.music' = 'Spotify',
'com.whatsapp' = 'WhatsApp',
'com.facebook.orca' = 'Facebook Messenger'
)
df_h1b$app_name <- app_mapping[df_h1b$my_app_id]
df_h1b <- df_h1b[, c('app_name', 'num_downloads', 'categ_app', 'level')]
colnames(df_h1b) <- c('App Name', 'Downloads (in B)', 'Category', 'Level')
df_h1b <- df_h1b[order(-df_h1b$`Downloads (in B)`), ]
row.names(df_h1b) <- NULL
# Render table using kable with LaTeX
kable(
head(df_h1b),
format = "latex",
caption = "Top 8 Apps by Downloads (in Billions)",
booktabs = TRUE,
longtable = TRUE
)
py_install("Markdown")
library(reticulate)
py_install("Markdown")
py_install("tabulate")
reticulate::repl_python()
#| label: fig-num-downloads-1-billion
#| fig-cap: "1 Billion+ Downloads in Level 1"
#| echo: false
#| warning: false
#| error: false
downloads_across_level = df_level_combined.copy()
downloads_across_level = downloads_across_level[downloads_across_level['level'] == '1'].copy()
# Add '1B Downloads' column
downloads_across_level['1B Downloads'] = downloads_across_level['num_downloads'] >= 1_000_000_000
# Filter for apps with 1 billion or more downloads
billion_downloads = downloads_across_level[downloads_across_level['1B Downloads'] == True]
# Prepare data for pie chart
billion_downloads_summary = billion_downloads['categ_app'].value_counts().reset_index()
billion_downloads_summary.columns = ['Category', 'Number of Apps']
# Data for the pie chart
sizes = billion_downloads_summary['Number of Apps']
labels = billion_downloads_summary['Category']
# Plotting the pie chart
plt.figure(figsize=(6, 6))  # Adjust the size of the pie chart
wedges, texts = plt.pie(
sizes,
labels=None,  # Hide labels on the pie chart itself
startangle=90,
colors=plt.cm.Paired(np.linspace(0, 1, len(labels)))  # Distinct colors
)
# Adding the custom legend
plt.legend(
wedges,
labels,
title="Categories",
loc="center left",
bbox_to_anchor=(1, 0, 0.5, 1)  # Custom legend position
)
# Adding a title
plt.title('Distribution of Apps with 1 Billion+ Downloads by Category')
# Display the chart
plt.tight_layout()
plt.show()
